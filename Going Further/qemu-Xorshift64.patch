diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
index cc8a8c1..d6bc660 100644
--- a/hw/misc/Kconfig
+++ b/hw/misc/Kconfig
@@ -1,3 +1,7 @@
+config MY_RNG
+    bool
+    default y
+
 config APPLESMC
     bool
     depends on ISA_BUS
diff --git a/hw/misc/meson.build b/hw/misc/meson.build
index 36c20d5..4322c71 100644
--- a/hw/misc/meson.build
+++ b/hw/misc/meson.build
@@ -1,3 +1,6 @@
+system_ss.add(when: 'CONFIG_MY_RNG', if_true: files('my-rng.c'))
+
+
 system_ss.add(when: 'CONFIG_APPLESMC', if_true: files('applesmc.c'))
 system_ss.add(when: 'CONFIG_EDU', if_true: files('edu.c'))
 system_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('vmcoreinfo.c'))
diff --git a/hw/misc/my-rng.c b/hw/misc/my-rng.c
new file mode 100644
index 0000000..bc7f129
--- /dev/null
+++ b/hw/misc/my-rng.c
@@ -0,0 +1,138 @@
+//define data structures and functions we need
+#include "qemu/osdep.h"
+#include "hw/pci/msi.h"
+#include "hw/pci/pci.h"
+
+//data structure representing the device
+#define TYPE_MY_RNG "my_rng"
+#define MY_RNG(obj) OBJECT_CHECK(my_rng, (obj), TYPE_MY_RNG)
+
+typedef struct {
+    PCIDevice parent_obj; /* inherit from PCIDevice */
+    uint64_t xorshift_state; /* État interne de Xorshift64 */
+    uint64_t rng64_cache; /* Cache pour le nombre 64-bit généré */
+    MemoryRegion mmio; /* data structure that will hold functions to read and write from the device's memory mapped registers*/
+} my_rng;
+
+/*
+ * Xorshift64 RNG - Algorithme simple et rapide
+ * Meilleure qualité que rand() de la stdlib C
+ * Source: Marsaglia, George (2003). "Xorshift RNGs"
+ */
+static uint64_t xorshift64(uint64_t *state) {
+    uint64_t x = *state;
+    x ^= x << 13;
+    x ^= x >> 7;
+    x ^= x << 17;
+    *state = x;
+    return x;
+}
+
+//functions that will run when the device's memory mapped registers are read/written:
+static uint64_t mmio_read(void *opaque, hwaddr addr, unsigned size) {
+    my_rng *dev = (my_rng *)opaque;
+    
+    /* Vérifier l'offset pour identifier le registre ciblé */
+    switch (addr) {
+        case 0x0: /* Registre RNG 32-bit - retourne un nombre aléatoire */
+            /* Utiliser Xorshift64 et retourner les 32 bits bas */
+            return (uint32_t)xorshift64(&dev->xorshift_state);
+        
+        case 0x4: /* Registre SEED - lecture non supportée (write-only) */
+            /* Retourner 0 car ce registre est en écriture seule */
+            return 0x0;
+        
+        case 0x8: /* Registre RNG 64-bit LOW - génère et retourne 32 bits bas */
+            /* Générer un nouveau nombre 64-bit avec Xorshift64 */
+            dev->rng64_cache = xorshift64(&dev->xorshift_state);
+            /* Retourner les 32 bits bas */
+            return (uint32_t)(dev->rng64_cache & 0xFFFFFFFF);
+        
+        case 0xC: /* Registre RNG 64-bit HIGH - retourne 32 bits haut du nombre précédent */
+            /* Retourner les 32 bits haut du nombre stocké */
+            return (uint32_t)(dev->rng64_cache >> 32);
+        
+        default:
+            /* Adresse invalide - retourner 0 */
+            return 0x0;
+    }
+}
+
+static void mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned size) {
+    my_rng *dev = (my_rng *)opaque; /* Récupérer le pointeur vers la structure du périphérique */
+    
+    /* Vérifier l'offset pour identifier le registre ciblé */
+    switch (addr) {
+        case 0x0: /* Registre RNG - écriture non supportée (read-only) */
+            /* Ne rien faire car ce registre est en lecture seule */
+            break;
+        
+        case 0x4: /* Registre SEED - initialise le générateur Xorshift64 */
+            /* Si seed est 0, utiliser une valeur par défaut (Xorshift64 ne doit pas être 0) */
+            if (val == 0) {
+                val = 0x123456789ABCDEF0ULL; /* Valeur par défaut non-nulle */
+            }
+            /* Initialiser l'état de Xorshift64 */
+            dev->xorshift_state = val;
+            break;
+        
+        default:
+            /* Adresse invalide - ne rien faire */
+            break;
+    }
+}
+
+static const MemoryRegionOps my_rng_ops = {/*data structure that contain members pointing to both functions */
+    .read = mmio_read,
+    .write = mmio_write,
+};
+
+
+//series of initialisation functions
+static void my_rng_realize(PCIDevice *pdev, Error **errp) {/* function that initialises an instance of the virtual random number generator*/
+    my_rng *s = MY_RNG(pdev);
+    
+    /* Initialiser Xorshift64 avec une seed par défaut */
+    s->xorshift_state = 0x123456789ABCDEF0ULL;
+    s->rng64_cache = 0;
+    
+    memory_region_init_io(&s->mmio, OBJECT(s), &my_rng_ops, s,
+                          "my_rng", 4096); /*Creating a region of I/O memory for the memory mapped registers with memory_region_init. That region has a size of 4 KB which is much larger than what we need (we have 2 registers of 4 bytes each) but corresponds to the size of a memory page.*/
+    pci_register_bar(&s->parent_obj, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);/*Registering the device on the PCI bus*/
+}
+/*
+my_rng_class_init will run once when Qemu starts and define a few characteristics common to all instances of our virtual device,
+ such as an easily identifiable device ID (0xcafe).
+ A member realize of the corresponding PCIDeviceClass data structure also points to the per-instance initialisation function my_rng_realize.
+*/
+static void my_rng_class_init(ObjectClass *class, void *data) {
+    DeviceClass *dc = DEVICE_CLASS(class);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+    k->realize = my_rng_realize;
+    k->vendor_id = PCI_VENDOR_ID_QEMU;
+    k->device_id = 0xcafe;
+    k->revision = 0x10;
+    k->class_id = PCI_CLASS_OTHERS;
+    
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+}
+
+static void my_rng_register_types(void) {
+    static InterfaceInfo interfaces[] = {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { },
+    };
+
+    static const TypeInfo my_rng_info = {
+        .name = TYPE_MY_RNG,
+        .parent = TYPE_PCI_DEVICE,
+        .instance_size = sizeof(my_rng),
+        .class_init    = my_rng_class_init,
+        .interfaces = interfaces,
+    };
+
+    type_register_static(&my_rng_info);
+}
+
+type_init(my_rng_register_types);
