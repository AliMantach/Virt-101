diff --git a/drivers/misc/Makefile b/drivers/misc/Makefile
index f2a4d1ff6..e9bf18172 100644
--- a/drivers/misc/Makefile
+++ b/drivers/misc/Makefile
@@ -2,7 +2,7 @@
 #
 # Makefile for misc devices that really don't fit anywhere else.
 #
-
+obj-y += my-rng.o
 obj-$(CONFIG_IBM_ASM)		+= ibmasm/
 obj-$(CONFIG_IBMVMC)		+= ibmvmc.o
 obj-$(CONFIG_AD525X_DPOT)	+= ad525x_dpot.o
diff --git a/drivers/misc/my-rng.c b/drivers/misc/my-rng.c
new file mode 100644
index 000000000..3501f45bb
--- /dev/null
+++ b/drivers/misc/my-rng.c
@@ -0,0 +1,98 @@
+//necessary includes and definitions
+#include <linux/ioctl.h>
+#include <linux/init.h>
+#include <linux/module.h>
+#include <linux/kernel.h>
+#include <linux/fs.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
+
+// Define ioctl commands
+#define MY_RNG_IOCTL_RAND _IOR('q', 1, unsigned int)
+#define MY_RNG_IOCTL_SEED _IOW('q', 1, unsigned int)
+//macro with the base physical address where the device's registers are mapped into memory
+/*
+00:04.0 Unclassified device [00ff]: Device 1234:cafe (rev 10)
+        Subsystem: Red Hat, Inc. Device 1100
+        Flags: fast devsel
+        Memory at febf1000 (32-bit, non-prefetchable) [size=4K]
+        */
+#define DEVICE_BASE_PHYS_ADDR 0xfebf1000
+
+//pointer that will hold the location where the device's registers are mapped in virtual memory (recall that the CPU can only access virtual memory)
+void *devmem = 0x0;
+
+//functions that will access the device. These will be called when the user land application invokes ioctl on the virtual file /dev/my_rng_driver
+
+static long my_rng_ioctl(struct file *file, unsigned int cmd, unsigned long arg) {
+    unsigned int value;
+    int ret;
+
+    switch (cmd) {
+        
+        case MY_RNG_IOCTL_RAND:
+            /* Application requests a new random number */
+            /* Lire un nombre aléatoire depuis le registre à l'offset 0 */
+            value = ioread32(devmem);
+            
+            /* Copier le nombre aléatoire vers l'espace utilisateur */
+            ret = copy_to_user((unsigned int __user *)arg, &value, sizeof(unsigned int));
+            if (ret != 0) {
+                return -EFAULT; // Erreur lors de la copie vers l'espace utilisateur
+            }
+            break;
+
+        case MY_RNG_IOCTL_SEED:
+            /* Application requests to seed the RNG */
+            /* Copier la valeur de seed depuis l'espace utilisateur */
+            ret = copy_from_user(&value, (unsigned int __user *)arg, sizeof(unsigned int));
+            if (ret != 0) {
+                return -EFAULT; // Erreur lors de la copie depuis l'espace utilisateur
+            }
+            
+            /* Écrire la valeur de seed dans le registre à l'offset 4 */
+            iowrite32(value, devmem + 4);
+            break;
+
+        default:
+            return -ENOTTY; // unknown command
+    }
+
+    return 0;
+}
+
+static struct file_operations my_rng_fops = {
+    .unlocked_ioctl = my_rng_ioctl,
+};
+
+static int __init my_rng_driver_init(void) {
+    devmem = ioremap(DEVICE_BASE_PHYS_ADDR, 4096);
+
+    if(!devmem) {
+        printk(KERN_ERR "Failed to map device registers in memory");
+        return -1;
+    }
+
+    if (register_chrdev(250, "my_rng_driver", &my_rng_fops) < 0) {
+        printk(KERN_ERR "Failed to register my_rng_driver\n");
+        return -1;
+    }
+
+    printk("my_rng_driver loaded, registered ioctls 0x%lx (get a random "
+        "number) and 0x%lx (seed the generator) \n", MY_RNG_IOCTL_RAND,
+        MY_RNG_IOCTL_SEED);
+    return 0;
+}
+
+static void __exit my_rng_driver_exit(void) {
+    unregister_chrdev(250, "my_rng_driver");
+
+    if(devmem)
+        iounmap(devmem);
+
+    printk(KERN_INFO "my_rng_driver unloaded\n");
+}
+
+module_init(my_rng_driver_init);
+module_exit(my_rng_driver_exit);
+
diff --git a/init/main.c b/init/main.c
index 436d73261..15cb5d093 100644
--- a/init/main.c
+++ b/init/main.c
@@ -1459,6 +1459,39 @@ static int __ref kernel_init(void *unused)
 
 	do_sysctl_args();
 
+    printk("------------------------------------------------------------------\n");
+    printk("BEGIN MY-RNG TEST\n");
+    printk("------------------------------------------------------------------\n");
+    
+    // Map the area of physical memory corresponding to the device's registers
+    // (starting 0xfebf1000, size 4KB) somewhere in virtual memory at address
+    // devmem. Notice that the physical memory where the device's registers are
+    // present may be different on your computer, use lspci -v in the VM to
+    // find it
+    void *devmem = ioremap(0xfebf1000, 4096);
+    unsigned int data = 0x0;
+    if(devmem) {
+        for(int i=0; i<2; i++) {
+            // seed with 0x42 by writing that value in the seed register which
+            // is located at base address + 4 bytes
+            iowrite32(0x42, devmem+4);
+    
+            // obtain and print 5 random numbers by reading the relevant
+            // register located at base address + 0
+            for(int j=0; j<5; j++) {
+                data = ioread32(devmem);
+                printk("Round %d number %d: %u", i, j, data);
+            }
+        }
+    } else {
+        printk("ERROR: cannot map device registers\n");
+    }
+    
+    printk("------------------------------------------------------------------\n");
+    printk("END MY-RNG TEST\n");
+    printk("------------------------------------------------------------------\n");
+    
+
 	if (ramdisk_execute_command) {
 		ret = run_init_process(ramdisk_execute_command);
 		if (!ret)
