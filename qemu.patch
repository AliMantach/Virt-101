diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
index cc8a8c1..d6bc660 100644
--- a/hw/misc/Kconfig
+++ b/hw/misc/Kconfig
@@ -1,3 +1,7 @@
+config MY_RNG
+    bool
+    default y
+
 config APPLESMC
     bool
     depends on ISA_BUS
diff --git a/hw/misc/meson.build b/hw/misc/meson.build
index 36c20d5..4322c71 100644
--- a/hw/misc/meson.build
+++ b/hw/misc/meson.build
@@ -1,3 +1,6 @@
+system_ss.add(when: 'CONFIG_MY_RNG', if_true: files('my-rng.c'))
+
+
 system_ss.add(when: 'CONFIG_APPLESMC', if_true: files('applesmc.c'))
 system_ss.add(when: 'CONFIG_EDU', if_true: files('edu.c'))
 system_ss.add(when: 'CONFIG_FW_CFG_DMA', if_true: files('vmcoreinfo.c'))
diff --git a/hw/misc/my-rng.c b/hw/misc/my-rng.c
new file mode 100644
index 0000000..c7b8892
--- /dev/null
+++ b/hw/misc/my-rng.c
@@ -0,0 +1,104 @@
+//define data structures and functions we need
+#include "qemu/osdep.h"
+#include "hw/pci/msi.h"
+#include "hw/pci/pci.h"
+
+//data structure representing the device
+#define TYPE_MY_RNG "my_rng"
+#define MY_RNG(obj) OBJECT_CHECK(my_rng, (obj), TYPE_MY_RNG)
+
+typedef struct {
+    PCIDevice parent_obj; /* inherit from PCIDevice */
+    uint32_t seed_register; /* Seed register for RNG */
+    MemoryRegion mmio; /* data structure that will hold functions to read and write from the device's memory mapped registers*/
+} my_rng;
+
+//functions that will run when the device's memory mapped registers are read/written:
+static uint64_t mmio_read(void *opaque, hwaddr addr, unsigned size) {
+    /* Vérifier l'offset pour identifier le registre ciblé */
+    switch (addr) {
+        case 0x0: /* Registre RNG - retourne un nombre aléatoire */
+            /* Chaque lecture retourne un nouveau nombre aléatoire de 32 bits */
+            return (uint32_t)rand();
+        
+        case 0x4: /* Registre SEED - lecture non supportée (write-only) */
+            /* Retourner 0 car ce registre est en écriture seule */
+            return 0x0;
+        
+        default:
+            /* Adresse invalide - retourner 0 */
+            return 0x0;
+    }
+}
+
+static void mmio_write(void *opaque, hwaddr addr, uint64_t val, unsigned size) {
+    my_rng *dev = (my_rng *)opaque; /* Récupérer le pointeur vers la structure du périphérique */
+    
+    /* Vérifier l'offset pour identifier le registre ciblé */
+    switch (addr) {
+        case 0x0: /* Registre RNG - écriture non supportée (read-only) */
+            /* Ne rien faire car ce registre est en lecture seule */
+            break;
+        
+        case 0x4: /* Registre SEED - initialise le générateur de nombres aléatoires */
+            /* Sauvegarder la valeur de seed dans la structure du périphérique */
+            dev->seed_register = (uint32_t)val;
+            /* Initialiser le générateur avec la nouvelle seed */
+            srand(dev->seed_register);
+            break;
+        
+        default:
+            /* Adresse invalide - ne rien faire */
+            break;
+    }
+}
+
+static const MemoryRegionOps my_rng_ops = {/*data structure that contain members pointing to both functions */
+    .read = mmio_read,
+    .write = mmio_write,
+};
+
+
+//series of initialisation functions
+static void my_rng_realize(PCIDevice *pdev, Error **errp) {/* function that initialises an instance of the virtual random number generator*/
+    my_rng *s = MY_RNG(pdev);
+    memory_region_init_io(&s->mmio, OBJECT(s), &my_rng_ops, s,
+                          "my_rng", 4096); /*Creating a region of I/O memory for the memory mapped registers with memory_region_init. That region has a size of 4 KB which is much larger than what we need (we have 2 registers of 4 bytes each) but corresponds to the size of a memory page.*/
+    pci_register_bar(&s->parent_obj, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->mmio);/*Registering the device on the PCI bus*/
+}
+/*
+my_rng_class_init will run once when Qemu starts and define a few characteristics common to all instances of our virtual device,
+ such as an easily identifiable device ID (0xcafe).
+ A member realize of the corresponding PCIDeviceClass data structure also points to the per-instance initialisation function my_rng_realize.
+*/
+static void my_rng_class_init(ObjectClass *class, void *data) {
+    DeviceClass *dc = DEVICE_CLASS(class);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(class);
+
+    k->realize = my_rng_realize;
+    k->vendor_id = PCI_VENDOR_ID_QEMU;
+    k->device_id = 0xcafe;
+    k->revision = 0x10;
+    k->class_id = PCI_CLASS_OTHERS;
+    
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+}
+
+static void my_rng_register_types(void) {
+    static InterfaceInfo interfaces[] = {
+        { INTERFACE_CONVENTIONAL_PCI_DEVICE },
+        { },
+    };
+
+    static const TypeInfo my_rng_info = {
+        .name = TYPE_MY_RNG,
+        .parent = TYPE_PCI_DEVICE,
+        .instance_size = sizeof(my_rng),
+        .class_init    = my_rng_class_init,
+        .interfaces = interfaces,
+    };
+
+    type_register_static(&my_rng_info);
+}
+
+type_init(my_rng_register_types);
